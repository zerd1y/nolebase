# 黑马点评

>[!tip] 模块介绍
>主要功能模块：
>1. 用户登录（验证码登录、短信登录）
>2. 商户查询（地理位置、推荐）
>3. 点评功能（点赞、分页）
>4. 店铺签到、用户签到记录
>5. 商户缓存（ [[Redis]] 解决缓存击穿、雪崩、穿透）
>6. 热点评价、排行榜（基于点赞数）
>7. 缓存预热、逻辑过期、互斥锁等优化方案
>8. 后台管理（数据统计、用户管理）

| 技术                    | 说明                                  |
| --------------------- | ----------------------------------- |
| **Spring Boot**       | 核心框架，构建 REST API                    |
| **Spring MVC**        | 控制层实现                               |
| **Spring Data Redis** | 缓存、分布式锁、签到功能等                       |
| **MyBatis-Plus**      | 持久层 ORM 框架，简化 MyBatis               |
| **MySQL**             | 主数据库（业务数据）                          |
| **[[Redis]]**         | 缓存（商户缓存、验证码、签到等）、分布式计数、HyperLogLog等 |

## 技术指南

### Session 和 Cookie 的区别？

| 特性       | Cookie                                         | Session                                        |
| -------- | ---------------------------------------------- | ---------------------------------------------- |
| **存储位置** | 客户端（浏览器）                                       | 服务端（内存、文件、数据库或分布式缓存如 Redis）                    |
| **存储内容** | 通常只存储少量信息，最常见的是 **Session ID**                 | 存储**用户的大量敏感或非敏感数据**，如用户ID、用户名、登录状态、权限信息等       |
| **安全性**  | 相对较低。数据直接暴露在客户端，易被篡改或窃取                        | 较高。敏感数据存储在服务器端，客户端只持有 Session ID               |
| **容量限制** | 每个 Cookie 大小限制在 4KB 左右，且每个域名下的 Cookie 数量也有限制   | 理论上只受服务器存储能力的限制，容量更大                           |
| **生命周期** | 可以是会话级别 (浏览器关闭即失效)，也可以是持久化 (设置过期时间)            | 依赖于 Session ID 的有效性，通常服务器会设置一个超时时间。长时间不活动会自动失效 |
| **作用**   | 主要用于**客户端的状态维护**，让浏览器记住一些信息，最核心的是传递 Session ID | 主要用于**服务器端的状态维护**，让服务器记住用户是谁以及其相关信息            |
### 登录时：Session 和 Cookie 有什么作用？

- **用户提交登录信息 (如用户名、密码)：**
    
    - 用户在浏览器中输入信息并点击登录。
        
- **浏览器将登录信息发送给服务器：**
    
    - 这是一个普通的 HTTP POST 请求。
        
- **服务器验证身份：**
    
    - 服务器接收到用户名和密码。
        
    - 服务器查询数据库（或其他用户存储），验证用户名和密码是否匹配。
        
- **【Session 的作用】验证成功后，服务器创建 Session：**
    
    - 如果验证通过，服务器知道这是一个合法用户。
        
    - 服务器会为这个已登录的用户在**服务器端**创建一个唯一的“会话”记录。
        
    - 这个记录包含用户的身份信息（例如，`userId=123`，`username=zhangsan`，以及登录时间、权限等）。
        
    - 服务器会给这个 Session 记录分配一个**唯一的 Session ID**（例如 `ABCXYZ123`）。
        
    - 这个 Session ID 和对应的用户数据（Key-Value 对）会被存储在服务器端的某个地方，比如：
        
        - **在您的点评项目中，这个地方就是 Redis。** 服务器会将 `ABCXYZ123` 作为 Key，`{userId: 123, username: "zhangsan", ...}` 作为 Value 存储到 Redis 中，并通常会设置一个过期时间（比如 30 分钟不活动就失效）。
            
    - **作用总结：** Session 确保了服务器能够“记住”这位用户，以及该用户在登录后的各种状态信息。
        
- **【Cookie 的作用】服务器将 Session ID 发送给浏览器：**
    
    - 服务器将刚刚生成的 **Session ID** (`ABCXYZ123`) 放置在一个 HTTP 响应头中的 `Set-Cookie` 字段里。
        
    - 这个 `Set-Cookie` 指令告诉浏览器：“嘿，把这个 `Session ID` (通常命名为 `JSESSIONID` 或 `sid` 等) 存起来！”
        
    - 服务器还会设置 Cookie 的一些属性，比如过期时间、作用域等。
        
    - **作用总结：** Cookie 的主要作用是作为**Session ID 的载体**。它将服务器为用户创建的 Session ID 传递回客户端浏览器，并在用户后续的请求中，由浏览器自动带回给服务器。
        
- **浏览器存储 Cookie：**
    
    - 浏览器接收到服务器的响应后，将这个包含 `Session ID` 的 Cookie (例如 `JSESSIONID=ABCXYZ123`) 存储在本地。
        
- **用户后续访问（保持登录状态）：**
    
    - 当用户点击网站上的其他链接（例如“我的订单”、“发布评论”）时，**浏览器会自动将存储的 `JSESSIONID=ABCXYZ123` 这个 Cookie 附加到每个 HTTP 请求头中**，发送给服务器。
        
    - **作用总结：** Cookie 负责在每次请求时，将服务器之前分发给它的“身份凭证”（Session ID）传回给服务器。
        
- **【Session 的作用】服务器根据 Cookie 中的 Session ID 识别用户：**
    
    - 服务器接收到请求后，会从请求头中解析出 `Session ID` (`ABCXYZ123`)。
        
    - 服务器使用这个 `Session ID` 到其**服务器端存储**（例如 Redis）中去查找对应的 Session 数据。
        
    - 如果找到了，并且 Session 未过期，服务器就知道这个请求是来自 `userId=123` 的 `zhangsan` 用户，从而允许他执行相应的操作。
        
    - **作用总结：** Session 允许服务器根据客户端传来的 Session ID，查找到并恢复用户的身份和状态，从而维持用户的登录状态和个性化体验。

**核心区别和协作方式：**

- **Cookie 就像一张“门票”**，这张门票上写着一个**座位号**（Session ID），它存在你（浏览器）的口袋里。
    
- **Session 就像电影院里的“座位和你的预留信息”**，电影院（服务器）根据你门票上的座位号（Session ID），才能找到你的预留信息，并确认你是谁。
    

没有 Cookie（门票），服务器就无法从你那里获取到 Session ID，也就无法找到你的 Session。 没有 Session（服务器端的记录），即使有了 Cookie 中的 Session ID，服务器也无法知道你是谁。

所以，它们是相互依赖，共同实现 Web 应用中用户状态管理的基石。

### 拦截器和 ThreadLocal

#### 拦截器（服务端）

```java
public class LoginInterceptor implements HandlerInterceptor {  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        HttpSession session = request.getSession();  
        Object user = session.getAttribute("user");  
        if (user == null) {  
            response.setStatus(401);  
            return false;  
        }  
        UserHolder.saveUser( (UserDTO) user);  
        return true;  
    }  
  
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
        UserHolder.removeUser();  
    }  
}
```

#### HttpServletRequest 工作原理

调用 `HttpServeletRequest.getSession()` 时，SpringMVC（底层是 Servlet 容器，如 Tomcat）会做：
1. **检查请求中是否包含 Session ID：**
	- 它会检查当前 HTTP 请求的 `Cookie` 头中是否存在一个名为 `JSESSIONID`（或你配置的其他 Session Cookie 名称）的 Cookie
	- 如果存在，它会获取这个 `Session ID`
2. **根据 Session ID 查找 Session 对象：**
	- **关键!** Servlet 容器会使用这个 `Session ID` 到**服务器端**的 Session 存储中去查找对应的 `HttpSession` 对象
	- 在你的 Redis 点评项目中，这个 Session 存储就是 **Redis**。这意味着，当用户登录成功时，你的代码（或者 Spring Session 等框架）已经将 `UserDTO` 对象（或其序列化后的数据）以 `user` 为键，存储到了与该 `Session ID` 关联的 Redis 记录中
3. **返回 `HttpSession` 对象：**
	- 如果找到了对应的 `HttpSession` 对象，容器就将它返回给你
	- 如果没有找到 `Session ID`（比如首次访问），或者找到的 `Session ID` 无效/过期，那么 `request.getSession()` 会**创建一个新的 `HttpSession` 对象**，并生成一个新的 `Session ID`，然后将这个新的 `Session ID` 通过 `Set-Cookie` 头发送回浏览器

#### ThreadLocal

`ThreadLocal` 是 Java 提供的一种机制，它允许你创建一个**线程局部变量**

>核心思想

`ThreadLocal` 为每个使用它的线程都创建了一个变量副本。每个线程都操作自己的副本，互不干扰。

>登录认证中的作用

在 Web 应用中，特别是使用 Spring MVC 这样的框架时，每个 HTTP 请求通常会由服务器（如 Tomcat）分配给一个**独立的线程**来处理。从请求进入拦截器、到达 Controller、再到 Service 层，直到响应返回，整个流程都在这个同一个线程中执行。

当用户登录成功后，我们获取到了用户的 `UserDTO` 信息。在不使用 `ThreadLocal` 的情况下，你可能需要一层一层地将 `UserDTO` 作为参数传递给你的 Controller、Service、甚至 Dao 层方法

这样会导致代码冗余，并且很多业务方法本身并不需要直接操作 `UserDTO`，只是为了传递给下层方法

>`ThreadLocal` 的优点

- **简化代码：** 避免了在方法间层层传递用户信息的参数，使代码更简洁、可读性更好。
- **线程隔离：** 确保每个线程的数据独立，不会出现线程安全问题。

>`ThreadLocal` 的缺点

- 内存泄漏
- 滥用问题
- 调试难度
### Session 共享问题

解决方案：用 Redis 替代 Session

![](assets/1653319474181.png)

